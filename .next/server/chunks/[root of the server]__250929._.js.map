{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\nclass PrismaClientSingleton {// Define uma classe chamada PrismaClientSingleton, que implementa o padrão Singleton.\n\n  // Variável estática para armazenar a instância única do PrismaClient.\n  private static instance: PrismaClient;\n\n  // Construtor privado para impedir que instâncias sejam criadas fora da classe.\n  private constructor() {}\n\n  // Método público e estático para obter a instância do PrismaClient.\n  // Se a instância não existir, ela será criada.\n  public static getInstance(): PrismaClient {\n    // Verifica se a instância já foi criada. Se não, cria uma nova.\n    if (!PrismaClientSingleton.instance) {\n      PrismaClientSingleton.instance = new PrismaClient({ errorFormat: 'pretty' });\n    }\n    // Retorna a instância existente ou recém-criada.\n    return PrismaClientSingleton.instance;\n  }\n}\n\n// Chama o método getInstance() para obter a instância do PrismaClient.\n// Essa será a única instância usada em toda a aplicação.\nconst prisma = PrismaClientSingleton.getInstance();\n\n// Exporta a instância para ser utilizada em outros módulos da aplicação.\nexport default prisma;"],"names":[],"mappings":";;;AAAA;;AACA,MAAM;IAEJ,sEAAsE;IACtE,OAAe,SAAuB;IAEtC,+EAA+E;IAC/E,aAAsB,CAAC;IAEvB,oEAAoE;IACpE,+CAA+C;IAC/C,OAAc,cAA4B;QACxC,gEAAgE;QAChE,IAAI,CAAC,sBAAsB,QAAQ,EAAE;YACnC,sBAAsB,QAAQ,GAAG,IAAI,2GAAA,CAAA,eAAY,CAAC;gBAAE,aAAa;YAAS;QAC5E;QACA,iDAAiD;QACjD,OAAO,sBAAsB,QAAQ;IACvC;AACF;AAEA,uEAAuE;AACvE,yDAAyD;AACzD,MAAM,SAAS,sBAAsB,WAAW;uCAGjC"}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/src/app/api/util/hash.ts"],"sourcesContent":["import crypto from 'crypto';\n\nexport const padronizedHash = (password:string, salt:string) =>{\n    return crypto.pbkdf2Sync(password, salt, 10000, 128, 'sha512').toString('hex'); // Cria o hash\n}"],"names":[],"mappings":";;;AAAA;;AAEO,MAAM,iBAAiB,CAAC,UAAiB;IAC5C,OAAO,+FAAA,CAAA,UAAM,CAAC,UAAU,CAAC,UAAU,MAAM,OAAO,KAAK,UAAU,QAAQ,CAAC,QAAQ,cAAc;AAClG"}},
    {"offset": {"line": 104, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/src/app/api/routes/login/route.ts"],"sourcesContent":["import prisma from \"@/lib/prisma\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport crypto from 'crypto';\nimport { padronizedHash } from \"../../util/hash\";\nimport  jwt  from \"jsonwebtoken\";\n\nconst generateJWT = (user: any) => {\n    const payload = {\n        id: user.id,\n        email: user.email\n    };\n\n    const secretKey = process.env.JWT_SECRET_KEY || 'your-secret-key';\n    const token = jwt.sign(payload, secretKey, { expiresIn: '1h' }); // Gera o token\n\n    return token;\n};\n\n\nconst validateHash = (salt: string, storedHashedPassword:string, password: string) => {\n  \n    const passwordValidate = padronizedHash(password, salt)\n\n    if(storedHashedPassword === passwordValidate)\n    {\n        return true\n    }\n    return false\n}\n\nexport async function POST (request: NextRequest){\n    \n    try{\n        const body = await request.json()\n        const { email, password } = body\n\n        const user = await prisma.user.findUnique({where:{email}})\n\n        if (!user) {\n            return new NextResponse('User not found', { status: 404 })\n        }\n\n        const validatedPassword = validateHash(user.salt, user.hashedPassword, password)\n\n        if(!validatedPassword){\n            return new NextResponse('Invalid credentials', { status: 401 })\n        }\n        const token = generateJWT(user);\n        \n        return new NextResponse(JSON.stringify({ token }), { status: 200 });\n    } catch (err) {\n        console.error(err);\n        return new NextResponse('Error during login', { status: 500 });\n    }\n\n}"],"names":[],"mappings":";;;AAAA;AACA;AAEA;AACA;;;;;AAEA,MAAM,cAAc,CAAC;IACjB,MAAM,UAAU;QACZ,IAAI,KAAK,EAAE;QACX,OAAO,KAAK,KAAK;IACrB;IAEA,MAAM,YAAY,QAAQ,GAAG,CAAC,cAAc,IAAI;IAChD,MAAM,QAAQ,uIAAA,CAAA,UAAG,CAAC,IAAI,CAAC,SAAS,WAAW;QAAE,WAAW;IAAK,IAAI,eAAe;IAEhF,OAAO;AACX;AAGA,MAAM,eAAe,CAAC,MAAc,sBAA6B;IAE7D,MAAM,mBAAmB,CAAA,GAAA,mIAAA,CAAA,iBAAc,AAAD,EAAE,UAAU;IAElD,IAAG,yBAAyB,kBAC5B;QACI,OAAO;IACX;IACA,OAAO;AACX;AAEO,eAAe,KAAM,OAAoB;IAE5C,IAAG;QACC,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG;QAE5B,MAAM,OAAO,MAAM,sHAAA,CAAA,UAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAAC,OAAM;gBAAC;YAAK;QAAC;QAExD,IAAI,CAAC,MAAM;YACP,OAAO,IAAI,gIAAA,CAAA,eAAY,CAAC,kBAAkB;gBAAE,QAAQ;YAAI;QAC5D;QAEA,MAAM,oBAAoB,aAAa,KAAK,IAAI,EAAE,KAAK,cAAc,EAAE;QAEvE,IAAG,CAAC,mBAAkB;YAClB,OAAO,IAAI,gIAAA,CAAA,eAAY,CAAC,uBAAuB;gBAAE,QAAQ;YAAI;QACjE;QACA,MAAM,QAAQ,YAAY;QAE1B,OAAO,IAAI,gIAAA,CAAA,eAAY,CAAC,KAAK,SAAS,CAAC;YAAE;QAAM,IAAI;YAAE,QAAQ;QAAI;IACrE,EAAE,OAAO,KAAK;QACV,QAAQ,KAAK,CAAC;QACd,OAAO,IAAI,gIAAA,CAAA,eAAY,CAAC,sBAAsB;YAAE,QAAQ;QAAI;IAChE;AAEJ"}},
    {"offset": {"line": 196, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}