{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\nclass PrismaClientSingleton {// Define uma classe chamada PrismaClientSingleton, que implementa o padrão Singleton.\n\n  // Variável estática para armazenar a instância única do PrismaClient.\n  private static instance: PrismaClient;\n\n  // Construtor privado para impedir que instâncias sejam criadas fora da classe.\n  private constructor() {}\n\n  // Método público e estático para obter a instância do PrismaClient.\n  // Se a instância não existir, ela será criada.\n  public static getInstance(): PrismaClient {\n    // Verifica se a instância já foi criada. Se não, cria uma nova.\n    if (!PrismaClientSingleton.instance) {\n      PrismaClientSingleton.instance = new PrismaClient({ errorFormat: 'pretty' });\n    }\n    // Retorna a instância existente ou recém-criada.\n    return PrismaClientSingleton.instance;\n  }\n}\n\n// Chama o método getInstance() para obter a instância do PrismaClient.\n// Essa será a única instância usada em toda a aplicação.\nconst prisma = PrismaClientSingleton.getInstance();\n\n// Exporta a instância para ser utilizada em outros módulos da aplicação.\nexport default prisma;"],"names":[],"mappings":";;;AAAA;;AACA,MAAM;IAEJ,sEAAsE;IACtE,OAAe,SAAuB;IAEtC,+EAA+E;IAC/E,aAAsB,CAAC;IAEvB,oEAAoE;IACpE,+CAA+C;IAC/C,OAAc,cAA4B;QACxC,gEAAgE;QAChE,IAAI,CAAC,sBAAsB,QAAQ,EAAE;YACnC,sBAAsB,QAAQ,GAAG,IAAI,2GAAA,CAAA,eAAY,CAAC;gBAAE,aAAa;YAAS;QAC5E;QACA,iDAAiD;QACjD,OAAO,sBAAsB,QAAQ;IACvC;AACF;AAEA,uEAAuE;AACvE,yDAAyD;AACzD,MAAM,SAAS,sBAAsB,WAAW;uCAGjC"}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 104, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/src/app/api/util/hash.ts"],"sourcesContent":["import crypto from 'crypto';\n\nexport const padronizedHash = (password:string, salt:string) =>{\n    return crypto.pbkdf2Sync(password, salt, 10000, 128, 'sha512').toString('hex'); // Cria o hash\n}"],"names":[],"mappings":";;;AAAA;;AAEO,MAAM,iBAAiB,CAAC,UAAiB;IAC5C,OAAO,+FAAA,CAAA,UAAM,CAAC,UAAU,CAAC,UAAU,MAAM,OAAO,KAAK,UAAU,QAAQ,CAAC,QAAQ,cAAc;AAClG"}},
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/src/app/api/routes/signin/route.ts"],"sourcesContent":["import prisma from \"@/lib/prisma\";\nimport { error } from \"console\"\nimport { NextRequest, NextResponse } from \"next/server\"\nimport crypto from 'crypto';\nimport { padronizedHash } from \"../../util/hash\";\n\n\nconst createData = async (data: any) => {\n    const saltedHashedPassword = passwordEncrypt(data.password);\n\n    const fullData = await prisma.user.create({data:{\n        email:data.email,\n        salt:saltedHashedPassword.salt,\n        hashedPassword:saltedHashedPassword.hashedPassword\n    } })\n\n    return fullData;\n}\n\nconst passwordEncrypt = (password: string) => {\n    const salt = crypto.randomBytes(16).toString('hex'); // Gera um salt\n    const hashedPassword = padronizedHash(password, salt)\n    crypto.pbkdf2Sync(password, salt, 10000, 128, 'sha512').toString('hex'); // Cria o hash\n    return { salt, hashedPassword }; // Retorna hash e salt\n};\n\nexport async function POST(request: NextRequest){\n    try{\n        const body = await request.json(); // ao inves de request.body pq o nextjs precisa saber de forma explícita que o tipo de data será do tipo Json, já que existem outros formatos de requisição\n        //verificaçao zod\n        const data = await createData(body)\n        return new NextResponse('User created successfully', { status: 201 });\n    }\n    catch{\n        return error\n    }\n}\n\n\n\n\n\n\n\n// ao inves de request.body pq o nextjs precisa saber de forma explícita que o tipo de data será do tipo Json, já que existem outros formatos de requisição"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAGA,MAAM,aAAa,OAAO;IACtB,MAAM,uBAAuB,gBAAgB,KAAK,QAAQ;IAE1D,MAAM,WAAW,MAAM,sHAAA,CAAA,UAAM,CAAC,IAAI,CAAC,MAAM,CAAC;QAAC,MAAK;YAC5C,OAAM,KAAK,KAAK;YAChB,MAAK,qBAAqB,IAAI;YAC9B,gBAAe,qBAAqB,cAAc;QACtD;IAAE;IAEF,OAAO;AACX;AAEA,MAAM,kBAAkB,CAAC;IACrB,MAAM,OAAO,+FAAA,CAAA,UAAM,CAAC,WAAW,CAAC,IAAI,QAAQ,CAAC,QAAQ,eAAe;IACpE,MAAM,iBAAiB,CAAA,GAAA,mIAAA,CAAA,iBAAc,AAAD,EAAE,UAAU;IAChD,+FAAA,CAAA,UAAM,CAAC,UAAU,CAAC,UAAU,MAAM,OAAO,KAAK,UAAU,QAAQ,CAAC,QAAQ,cAAc;IACvF,OAAO;QAAE;QAAM;IAAe,GAAG,sBAAsB;AAC3D;AAEO,eAAe,KAAK,OAAoB;IAC3C,IAAG;QACC,MAAM,OAAO,MAAM,QAAQ,IAAI,IAAI,2JAA2J;QAC9L,iBAAiB;QACjB,MAAM,OAAO,MAAM,WAAW;QAC9B,OAAO,IAAI,gIAAA,CAAA,eAAY,CAAC,6BAA6B;YAAE,QAAQ;QAAI;IACvE,EACA,OAAK;QACD,OAAO,gGAAA,CAAA,QAAK;IAChB;AACJ,EAQA,2JAA2J"}},
    {"offset": {"line": 163, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}